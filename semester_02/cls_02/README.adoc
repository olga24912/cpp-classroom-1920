= Move semantics, Perfect forwarding
:source-highlighter: highlightjs
:revealjs_hash: true
:icons: font

C++ часть 2, cеминар #2

ИТМО, 17.02.2020

== Что нужно делать на семинаре?

[.step]
* На семинаре вам выдаются задачи.
* Вы начинаете решать их на семинаре и заканчиваете дома.
* Решения сдаются через `github`.
** Если нет репозитория, вам сюда: https://classroom.github.com/a/nMZ3dazP

=== Как оцениваются задачи

[.step]
* Задачи выдаются в понедельник в начале семинара.
* Задачу можно сдать до вечера среды (до 23:59) за 1.5 стоимости.
* До начала следующего семинара задачи принимаются за 0.75 стоимости.
* В конце семестра за дорешки ставится оценка.

=== Контрольные работы

* Раз в 3-4 семинара будет контрольная работа.
** По факту это семинар, который нельзя доделать дома.
* По контрольным работам будет выставлена отдельная оценка.

== Где семинар про ошибки?

[.step]
* Тема обработки ошибок будет рассмотрена в ходе других семинаров.
* Например, в этом семинаре нужно вспомнить про безопасность исключений.

== Move semantics

Реализация мув семантики в C++ возможна благодаря rvalue-ссылкам.

Они нужны, чтобы отдельно обрабатывать временные объекты.

=== Вопрос на понимание

Что выведет следующий код?

[source,cpp]
----
std::string hello = "Hello";

std::move(hello);
std::cout << hello << std::endl;
----

[.step]

* Ответ: "Hello\n".
* `std::move` не выполняет мув, он только конвертирует тип значения в rvalue-ссылку.

== Perfect forwarding

Что нужно помнить про perfect forwarding:

* Нужен исключительно в случаях, когда куда-то передается шаблонный параметр
* Шаблонный параметр должен иметь строго заданный вид:

[source,cpp]
----
template <..., typename T, ...>
void foo(..., T&& t, ...) {...}
----

== Задача 1 (1 балл)

Вы уже писали свой `scoped_ptr` и `shared_ptr`.

* `scoped_ptr` в принципе не подразумевал передачи владения, что плохо
* `shared_ptr` всегда дает раздельное владение, что часто не нужно

Нужен вариант для уникального владения указателем.

=== unique_ptr FTW

До появления rvalue ссылок, в C++ нельзя было написать `unique_ptr`.

Чтобы обеспечить уникальность владения, `unique_ptr` должен уметь создаваться только из временных значений.

ifdef::backend-revealjs[=== !]

Реализуйте класс `unique_ptr`, руководствуясь тестами.

Также реализуйте метод `make_unique` с 0..2 параметрами.

== Задача 2 (1 балл)

Реализуйте класс `optional<T>`, который умеет хранить опциональное значение типа `T`.

TODO: Тестов пока что нет, мы выложим их и обновим задание.

