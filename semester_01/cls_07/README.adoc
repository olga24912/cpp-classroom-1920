= Семинар №7: Операторы
:revealjs_theme: white
:revealjs_hash: true
:icons: font

== Разбор предыдущего семинара
Рассмотрим ошибки/улучшения задач предыдущего семинара


=== Конструктор

Используйте листы инициализации

[source, cpp]
----
// структура для иллюстрации
struct shared_buffer {
    char *data_;
    char size_;
};

shared_buffer::shared_buffer(size_t sz)
    : data_(new char[sz]{})
    , size_(sz)
{}
----

=== Подсчет ссылок

* `map` не ок — не нужно знать обо всех ссылках сразу
* NB: `map` vs `unordered_map`
** (см. асимптотики в стандарте)

=== `concat` за одну аллокацию

Возможен! Функции могут пользоваться спец. интерфейсами классов "для них"
[source, cpp]
----

struct lazy_string {
    /* .... */

    friend lazy_string concat(
        lazy_string const& lhs,
        lazy_string const& rhs
    );
};

----

ifdef::backend-revealjs[=== !]

[source, cpp]
----

lazy_string concat(lazy_string const& lhs, lazy_string const& rhs) {
    shared_buffer buf =
        shared_buffer(lhs.get_size() + rhs.get_size() + 1);

    // fill 'buf' with lhs.data_, rhs.data_

    return lazy_string(buf);  // private ctor call
}
----

== Задачи

В этом семинаре мы модифицируем написанный нами ранее `lazy_string`, 
используя операторы. 

=== Задача №0 (0 баллов)

Теперь, когда вы знакомы с `namespace`-ами, мы начнем их использовать во всех дорешках.

Занесите всё ваше решение в неймспейс `cls_07`.

ifdef::backend-revealjs[=== !]

WARNING: В дальшейшем используйте аналогичный неймспейс для ваших дорешек.

=== Задача №1 (0.5 балл)

Определите свободную функцию `find`, которая возвращает индекс вхождения подстроки. 

Приблизительная сигнатура функции:

[source,cpp]
----
int find(
    lazy_string s, 
    const char *what, 
    size_t start_ix = 0
);
----

ifdef::backend-revealjs[=== !]

WARNING: Функция `find` не должна копировать содержимое строки.

////
Функция `find` не должна копировать содержимое строки, а также не должна вызывать её
`вычисления`.
////


=== Задача №2 (1 балл)

Реализуйте следующие операторы для `lazy_string`:

* Оператор `<`.
** Сравнение -- лексикографическое.
* Операторы `+` и `+=`.

ifdef::backend-revealjs[=== !]

* Оператор `[]`, работающий как функция `at`.
* Оператор `<<` для вывода `lazy_string` в `ostream`.


=== Пример кода с использованием операторов

[source,cpp]
----
lazy_string hello = "Hello";
lazy_string world = "World";

world += "!";

std::cout << hello + " " + world;

assert(hello < world && hello[0] == 'H');
----

=== Задача №3* (1 балл)

Сделайте конкатенацию ленивой.

Раньше при конкатенации вы (скорее всего) сразу же создавали
новый `shared_buffer` с содержимым строки-результата.

Теперь вам предлагается отложить это на как можно более поздний срок (все тесты при этом должны проходить).

ifdef::backend-revealjs[=== !]

Теперь часть операций неизбежно будет вызывать "сборку" строки из кусочков.

Пример:

[source,cpp]
----
lazy_string s = "Hello";

s += " ";
s += "World!"; // три буффера: 'Hello', ' ' и 'World!'

std::cout << s; // не нужно объединять буферы
std::cout << s[0]; // всё ещё не нужно
std::cout << s.c_str(); // придется объединить буферы
----

=== Ограничения и послабления

* Теперь `c_str` не обязан работать за O(1) при первом вызове, но должен при последующих вызовах.
* `at` и `[]` должны работать за `O(n log n)`.
** Посмотрите в сторону std::map.

ifdef::backend-revealjs[=== !]

[NOTE]
====
Теперь вы можете вводить собственные классы для решения задач.

Этой возможностью стоит пользоваться, чтобы делать решение проще и лучше.
====

ifdef::backend-revealjs[=== !]

[NOTE]
====
Эту задачу будет проще всего решить, введя несколько новых абстракций, например:

* Класс для обхода символов в `lazy_string` (итератор).
* Класс для объединения нескольких `shared_buffer`.
====

