= Семинар №7: Операторы
:revealjs_theme: white
:revealjs_hash: true
:icons: font

== Разбор предыдущего семинара
Рассмотрим ошибки/улучшения задач предыдущего семинара


=== Конструктор

Используйте листы инициализации

[source, cpp]
----
// структура для иллюстрации
struct shared_buffer {
    char *data_;
    char size_;
};

shared_buffer::shared_buffer(size_t sz)
    : data_(new char[sz]{})
    , size_(sz)
{}
----

=== Подсчет ссылок

* `map` не ок — не нужно знать обо всех ссылках сразу
* NB: `map` vs `unordered_map`
** (см. асимптотики в стандарте)

=== `concat` за одну аллокацию

Возможен! Функции могут пользоваться спец. интерфейсами классов "для них"
[source, cpp]
----

struct lazy_string {
    /* .... */

    friend lazy_string concat(
        lazy_string const& lhs,
        lazy_string const& rhs
    );
};

----

ifdef::backend-revealjs[=== !]

[source, cpp]
----

lazy_string concat(lazy_string const& lhs, lazy_string const& rhs) {
    shared_buffer buf =
        shared_buffer(lhs.get_size() + rhs.get_size() + 1);

    // fill 'buf' with lhs.data_, rhs.data_

    return lazy_string(buf);  // private ctor call
}
----

== Использование CMake

Если вы решили задачу, убедитесь в том, что ваше решение можно собрать через `CMake`.

ifdef::backend-revealjs[=== !]

Для этого достаточно добавить/раскомментировать строчку `add_executable` в `CMakeLists.txt`.

=== Пример

В [yellow-background]*текущей* дорешке есть два таргета, добавленных командой `add_executable`:

[source,cmake]
----
add_executable(task-1-test <компилируемые файлы>)
add_executable(task-2-test <компилируемые файлы>)
----

ifdef::backend-revealjs[=== !]

Если вы добавили свой файл `my_awesome.cpp`, и используете его во втором задании,
то модифицируйте соответствующий таргет.

[source,cmake]
----
...
add_executable(task-2-test my_awesome.cpp ...)
----

== Задачи

В этом семинаре мы модифицируем написанный нами ранее `lazy_string`, 
используя операторы. 

=== Задача №0 (0 баллов)

Теперь, когда вы знакомы с `namespace`-ами, мы начнем их использовать во всех дорешках.

Занесите всё ваше решение в неймспейс `cls_07`.

ifdef::backend-revealjs[=== !]

WARNING: В дальшейшем используйте аналогичный неймспейс для ваших дорешек.

=== Задача №1 (0.5 балл)

Определите свободную функцию `find`, которая возвращает индекс вхождения подстроки.

Если подстрока не найдена, верните константу `npos`, определенную в `lazy_string`.
Значение для `npos` выберите и обоснуйте в комментарии.

Приблизительная сигнатура функции:

[source,cpp]
----
size_t find(
    lazy_string s, 
    char const *what,
    size_t start_ix = 0
);
----

ifdef::backend-revealjs[=== !]

WARNING: Функция `find` не должна копировать содержимое строки.

////
Функция `find` не должна копировать содержимое строки, а также не должна вызывать её
`вычисления`.
////


=== Задача №2 (1 балл)

Реализуйте следующие операторы для `lazy_string`:

* Оператор `<`.
** Сравнение -- лексикографическое.
* Операторы `+` и `+=`.

ifdef::backend-revealjs[=== !]

* Оператор `[]`, работающий как функция `at`.
* Оператор `<<` для вывода `lazy_string` в `ostream`.


=== Пример кода с использованием операторов

[source,cpp]
----
lazy_string hello = "Hello";
lazy_string world = "World";

world += "!";

std::cout << hello + " " + world;

assert(hello < world && hello[0] == 'H');
----

=== Задача №3* (1 балл)

Сделайте конкатенацию ленивой.

Раньше при конкатенации вы (скорее всего) сразу же создавали
новый `shared_buffer` с содержимым строки-результата.

Теперь вам предлагается отложить это на как можно более поздний срок (все тесты при этом должны проходить).

ifdef::backend-revealjs[=== !]

Теперь часть операций неизбежно будет вызывать "сборку" строки из кусочков.

Пример:

[source,cpp]
----
lazy_string s = "Hello";

s += " ";
s += "World!"; // три буффера: 'Hello', ' ' и 'World!'

std::cout << s; // не нужно объединять буферы
std::cout << s[0]; // всё ещё не нужно
std::cout << s.c_str(); // придется объединить буферы
----

=== Ограничения и послабления

* Теперь `c_str` не обязан работать за `O(1)` при первом вызове, но должен при последующих вызовах.
* `at` и `[]` должны работать за `O(log n)`.
** Посмотрите в сторону std::map.

ifdef::backend-revealjs[=== !]

[NOTE]
====
Теперь вы можете вводить собственные классы для решения задач.

Этой возможностью стоит пользоваться, чтобы делать решение проще и лучше.
====

ifdef::backend-revealjs[=== !]

[NOTE]
====
Эту задачу будет проще всего решить, введя несколько новых абстракций, например:

* Класс для обхода символов в `lazy_string` (итератор).
* Класс для объединения нескольких `shared_buffer`.
====

