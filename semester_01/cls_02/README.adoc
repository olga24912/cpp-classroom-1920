= Семинар №2: Сборка C++ Программ
:revealjs_theme: white

== Цели занятия

* Разобраться с особенностями сборки C++ проектов, состоящих из нескольких единиц трансляции.
* Попробовать объявлять, определять и использовать функции и переменные в разных единицах трансляции.

== Процесс компиляции

Компиляция (упрощенно) происходит в два этапа:

* Компиляция единиц трансляции в объектные файлы.
* Линковка единиц трансляции.

=== Компиляция в объектные файлы

Есть файлы `code.cpp` и `main.cpp`.

Получим из них объектные файлы с помощью флага `-c` (`/c`):

----
$ g++ code.cpp main.cpp -c
----

или

----
$ cl code.cpp main.cpp /c
----

ifdef::backend-revealjs[=== !]

Компиляция каждой единицы трансляции (каждого .cpp файла) *происходит отдельно!*

=== Линковка в исполняемый файл

Полученные на прошлом этапе объектные файлы нужно слинковать в исполняемый файл с помощью линковщика:

----
$ g++ code.o main.o -o main
----

или

----
$ LINK code.obj main.obj /OUT:main.exe
----

ifdef::backend-revealjs[=== !]

Линковщику необходимы все объектные файлы, иначе будут ошибки поиска символов.

ifdef::backend-revealjs[=== !]

Многие компиляторы (`g\++`, `clang++`, `cl`) по-умолчанию выполняют сразу и компиляцию, и линковку.

== Внутренняя vs Внешняя линковка?

В чем разница?

В чем преимущества/недостатки?

== Задачи

При решении задач рекомендуется:

* Пользоваться компилятором напрямую через командную строку.
* Компилировать в два шага: компиляция и линковка.

=== Задача №1

В этой задаче нельзя использовать заголовочные файлы!

* `math.cpp`
** Определите функции `int add(int, int)` и `int multiply(int, int)`
* `main.cpp`
** Выведите в консоль `mul(add(1, 2), 4)`

=== Задача №2

* `a.hpp`
** объявление константы `A1`
** определение константы `A2 = 20`
* `a.cpp`
** определение `A1 = 10`
* `main.cpp`
** вывод `A1 + A2` в консоль

=== Задача №3

* `a.cpp`
** объявление и определение переменной `global_a` со значением 10 + 20
* `main.cpp`
** вывод `global_a`

=== Задача №4

Показать 2 способа задания переменной с внутренней компоновкой.

=== Задача №5: Inline trick

* `singleton.hpp`
** Определение функции `int inc()`, инкрементирующей счетчик и возвращающий его значение (начиная с нуля).

ifdef::backend-revealjs[=== !]

* `first.cpp`
** Определение функции `int inc_first()`, вызывающей `inc`
* `second.cpp`
** Определение функции `int inc_second()`, вызывающей `inc`

ifdef::backend-revealjs[=== !]

* `main.cpp`
** Последовательный вызов `inc_first` и `inc_second`, проверка, что они
выводят 1, 2, 3, 4, ...

=== Задача №6

* `sum.h`
** объявить функцию `int sum(int, int)`
* `sum.c`
** определить функцию `int sum(int, int)`
* `main.cpp`
** подключить `sum.h`
** вызвать и вывести `sum(10, 20)`

ifdef::backend-revealjs[=== !]

Компилировать необходимо соответствующими компиляторами в отдельные объектные файлы (`gcc`/`clang`/`cl` для комиляции `C`).
