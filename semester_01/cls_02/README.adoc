= Семинар №2: Сборка C++ Программ
:revealjs_theme: white

== Типичные ошибки прошлого семинара

Рассмотрим типичные ошибки/недочеты, допущенные при решении прошлого семинара.

=== Неконсистентные типы

[source,cpp]
----
int64_t id(int64_t n) {
    int tmp = n;
    return n;
}
----

Где проблемы?

=== Переполнение

[source,cpp]
----
void say_hello(uint64_t times) {
    for (int64_t i = 1; i <= times; ++i) {
        cout << "Hello world " << i;
    }
}
----

Где проблемы?

ifdef::backend-revealjs[=== !]

[source,cpp]
----
void say_hello(uint64_t times) {
    for (uint64_t i = 1; i <= times; ++i) {
        cout << "Hello world " << i;
    }
}
----

Стало лучше?

ifdef::backend-revealjs[=== !]

Вариант исправления:

[source,cpp]
----
void say_hello(uint64_t times) {
    for (uint64_t i = 0; i < times; ++i) {
        uint64_t j = i + 1;
        cout << "Hello world " << j;
    }
}
----

=== Лишние заголовочные файлы и using

.header.hpp
[source,cpp]
----
#include <iostream>
#include <cstdint>
#include <string>

using namespace std;

void print_n_times(uint64_t times, string str);
----

Что здесь лишнее?

ifdef::backend-revealjs[=== !]

Оставим только необходимое:

.header.hpp
[source,cpp]
----
#include <cstdint>
#include <string>

void print_n_times(uint64_t times, std::string str);
----

=== Инициализация переменных

[source,cpp]
----
void usage() {
    ...
    int tmp; // 1
    ...
    tmp = 10; // 2
    ....
}
----

Что находится в `tmp` между 1 и 2?

ifdef::backend-revealjs[=== !]

Если возможно, инициализируйте переменные сразу при объявлении:

[source,cpp]
----
void usage() {
    ...
    int tmp = 10;
    ....
}
----


== Цели занятия

* Разобраться с особенностями сборки C++ проектов, состоящих из нескольких единиц трансляции.
* Попробовать объявлять, определять и использовать функции и переменные в разных единицах трансляции.

== Процесс компиляции

Компиляция (упрощенно) происходит в два этапа:

* Компиляция единиц трансляции в объектные файлы.
* Линковка единиц трансляции.

=== Компиляция в объектные файлы

Есть файлы `code.cpp` и `main.cpp`.

Получим из них объектные файлы с помощью флага `-c` (`/c`):

----
$ g++ code.cpp main.cpp -c
----

или

----
$ cl code.cpp main.cpp /c
----

ifdef::backend-revealjs[=== !]

Компиляция каждой единицы трансляции (каждого .cpp файла) *происходит отдельно!*

=== Линковка в исполняемый файл

Полученные на прошлом этапе объектные файлы нужно слинковать в исполняемый файл с помощью линковщика:

----
$ g++ code.o main.o -o main
----

или

----
$ LINK code.obj main.obj /OUT:main.exe
----

ifdef::backend-revealjs[=== !]

Линковщику необходимы все объектные файлы, иначе будут ошибки поиска символов.

ifdef::backend-revealjs[=== !]

Многие компиляторы (`g\++`, `clang++`, `cl`) по-умолчанию выполняют сразу и компиляцию, и линковку.

== Внутренняя vs Внешняя линковка?

В чем разница?

В чем преимущества/недостатки?

== Задачи

При решении задач рекомендуется:

* Пользоваться компилятором напрямую через командную строку.
* Компилировать в два шага: компиляция и линковка.

=== Задача №1

В этой задаче нельзя использовать заголовочные файлы!

* `math.cpp`
** Определите функции `int add(int, int)` и `int multiply(int, int)`
* `main.cpp`
** Выведите в консоль `mul(add(1, 2), 4)`

=== Задача №2

* `a.hpp`
** объявление константы `A1`
** определение константы `A2 = 20`
* `a.cpp`
** определение `A1 = 10`
* `main.cpp`
** вывод `A1 + A2` в консоль

=== Задача №3

* `a.cpp`
** объявление и определение переменной `global_a` со значением 10 + 20
* `main.cpp`
** вывод `global_a`

=== Задача №4

Показать 2 способа задания переменной с внутренней компоновкой.

=== Задача №5: Inline trick

* `singleton.hpp`
** Определение функции `int inc()`, инкрементирующей счетчик и возвращающий его значение (начиная с нуля).

ifdef::backend-revealjs[=== !]

* `first.cpp`
** Определение функции `int inc_first()`, вызывающей `inc`
* `second.cpp`
** Определение функции `int inc_second()`, вызывающей `inc`

ifdef::backend-revealjs[=== !]

* `main.cpp`
** Последовательный вызов `inc_first` и `inc_second`, проверка, что они
выводят 1, 2, 3, 4, ...

=== Задача №6

* `sum.h`
** объявить функцию `int sum(int, int)`
* `sum.c`
** определить функцию `int sum(int, int)`
* `main.cpp`
** подключить `sum.h`
** вызвать и вывести `sum(10, 20)`

ifdef::backend-revealjs[=== !]

Компилировать необходимо соответствующими компиляторами в отдельные объектные файлы (`gcc`/`clang`/`cl` для комиляции `C`).
