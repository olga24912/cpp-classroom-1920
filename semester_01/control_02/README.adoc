= Контрольная работа №2: Math equations
:revealjs_theme: white

== Правила сдачи контрольной работы

* решение должно быть закоммичено в ветку с названием `sem_1_control_02`
* должен быть создан пулл-реквест с названием "Control 2, <фамилия> <имя>"
** не забудьте добавить своего практика в ревьюеры

ifdef::backend-revealjs[=== !]

* в качестве main-а можно воспользоваться smoke-тестами, которые будут вам предоставлены
* ваш код должен быть в неймспейсе expression
* при решении можно пользоваться классами, которые явно упомянуты в сниппетах в презентации, а также мапами и векторами
* про другие вещи — спрашивать отдельно

== Как пользоваться тестами

* есть четыре закомментированных define-а: task_1, task_1_5, task_2 и task_3
* если раскомментировать task_1, то при запуске main будут запущены тесты для первого задания; аналогично для task_2 и task_3
* раскомментированные дефайны *нужно коммитить в гит*

== Задание: калькулятор

Нужно написать классы для вычисления простых арифметических выражений.

ifdef::backend-revealjs[=== !]

[source,cpp]
----
using namespace expression;
Expression* main_expr = new Mul(
    new Plus(new Val(10), new Var("y")),
    new Var("x")
); // expression (10 + y) * x, presented with our classes

Context ctx;
ctx.set_var("x", 3);
ctx.set_var("y", 2);

main_expr->print(cout); // prints "(10 + y) * x"
cout << main_expr->eval(ctx) << endl; // prints 60

delete main_expr; // all memory is cleared
----

=== Некоторые справки

* int64_t лежит в заголовочном файле cstdint

* Исключения:

----
#include <stdexcept>

// при возникновении ошибочных ситуаций
// нужно бросать runtime_exception с описанием
// ошибки
throw std::runtime_error("<Сообщение о проблеме>");
----

=== Задача 1 (0.5 балла)

Реализуйте класс Expression - узел дерева вычисления

И три его наследника: Val, Add и Mul.

Класс Expression имеет виртуальный метод print, который позволяет распечатать его в переданный выходной поток.

ifdef::backend-revealjs[=== !]

`Val` обозначает число, должен иметь конструктор от переменной типа `int64_t`.

`Add` обозначает сложение двух выражений, должен иметь конструктор, принимающий два `Expression*`.

`Mul` — то же, что и `Add`, только для умножения.

=== Задача 1.5 (0.5 балла)

Добавьте в класс Expression виртуальный метод eval, не принимающий аргументов и вычисляющий значение выражения.

Реализуйте его в наследниках так, чтобы вычисления происходили правильно.

=== Задача 2 (1 балл)
Реализуйте класс Var — переменную.

Он должен быть наследником `Expression` и иметь конструктор от `std::string` (имени переменной).

ifdef::backend-revealjs[=== !]

Добавьте класс `Context`, предназначенный для хранения значений именованных переменных.

Этот класс должен иметь методы для выставления и получения значения переменных, а также для проверки, выставлено ли оно.

Добавьте в `Expression` виртуальный метод `eval`, принимающий `Context` и считающий значение выражения с учетом значений переменных в контексте.

ifdef::backend-revealjs[=== !]

----

class Context {
public:
// бросает исключение, если переменной нет
int64_t get_var(std::string const& name) const;
// перезаписывает переменную, если она уже есть
void set_var(std::string const& name, int64_t value);
bool var_is_set(std::string const& name) const;
};

----

=== Задача 3 (1 балл)
Добавьте в Expression метод simplified, принимающий контекст и возвращающий новый Expression, который является максимально упрощенным вариантом исходного выражения с учётом переданного контекста.

=== Примеры:

----
(1 + 2 * x).simplified({x = 2}) => 5
(1 + 2 * x).simplified({}) => 1 + 2 * x
(x * 2 + y * 3).simplified({x = 3}) => 6 + y * 3
----

=== Важные детали

* `simplified` должен возвращать *новый, независимый объект*.
* `0 * x` не упрощается до `0`, если переменная `x` отсутствует в контексте.

////
=== Задача 4** (2 балла)
Напишите функцию parse, которая производит разбор строки и создает на её основе Expression*
Expression* parse(std::string const& str) {...}
////

