= Шаблоны в C++: template functions, template classes, template instantiation, template parameter inference
:source-highlighter: highlightjs

== Задачи занятия

* Научиться писать шаблонные функции.
* Увидеть работу вывода шаблонных типов для шаблонных функций.
* Научиться писать шаблонные классы и использовать их.

== Задача 1(1 балл)

Реализовать 4 шаблонные функции (аналоги из стандартной библиотеки). Постарайтесь минимизировать требования к шаблонным типам.

Во всех заданиях диапазон вида `[begin, end)`.

За каждую функцию дается 0.25 балла.

ifdef::backend-revealjs[=== !]

* `fill` - принимает два указателя на начало и конец диапазона и значение, которым заполнит этот диапазон.
* `generate` - принимает два указателя на начало и конец диапазона и функцию-генератор значения.

ifdef::backend-revealjs[=== !]

* `copy` - принимает три указателя: два на начало и конец диапазона источника (source) и один на начало диапазона назначения (destination).
* `for_each` - принимает два указателя на начало и конец диапазона и функтор. Выполняет функтор над каждым элементом.

== Задача 2(2 балла)

Реализовать шаблонный односвязный список и реализовать поверх него FIFO-очередь.

ifdef::backend-revealjs[=== !]

Необходимый интерфейс очереди:

* Конструктор, конструктор копирования, оператор=, деструктор
* Вставка в конец очереди push(const T&)
* Удаление первого элемента void pop()
* Доступ к первому элементу `T& front, const T& front`
* Размер очереди `size_t size()`

== Задача 3 (2 балл)

Реализовать шаблонную очередь с приоритетами.
Интерфейс такой же, как в предыдущей задаче.
Если не хотите реализовывать алгоритм - можете использовать функции STL для работы с двоичной кучей.
Если сделали и заскучали - добавьте к классу шаблонный параметр - компаратор со значением по-умолчанию.(см. `std::priority_queue`)