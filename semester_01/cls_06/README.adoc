= Семинар №6: Классы 
:revealjs_theme: white
:revealjs_hash: true
:icons: font

== Разбор контрольной работы №1

Контрольная проверяла следующие вещи: 

* Работа со структурами.
* Работа с памятью.
* Аккуратная работа с указателями.

=== Deep dive into code

Посмотрим на сниппетах

=== Задача №1

Важные моменты: 

* Копирование строки-параметра.
* Из `get_text`/`get_user` **не нужно** возвращать копии строк.
* Правильная очистка в `destroy_posts`.
* `sizeof(str) != strlen(str)`

=== Задача №2

Задача: удалить посты с плохим содержимым.

Важные моменты:

* Нужно запомнить _первый не удаленный пост_ -- он будет новой головой. 
* Если удаляем пост, то у следующего нужно обновить предыдущий.
* Для удаления поста лучше всего использовать `destroy_posts`.

=== Задача №3

Задача: слить посты по времени. 

Самый удобный способ выглядит так:

* Пока есть две ленты, смотрим на их верхушки; более новый пост прикрепляем к новой ленте.
* Когда осталась одна лента, прикрепляем все посты из неё.

////
=== Разбор кода решения

== Задачи семинара

//* Улучшить понимание ООП.
* Поупражняться в написании классов.
////
////
== Структура vs Объект

В программировании есть следующая классификация сущностей:

* Данные:
** структуры
** `value classes`
** `data classes`
** ...
* Объекты.

ifdef::backend-revealjs[=== !]

Эта классификация очень условна, но полезна.

[.step]
* Q: Чем структуры отличаются от объектов?
* A:
+
Структура данных просто держит данные вместе.
+
Объект предоставляет поведение, скрывая данные.

=== Пример

Что из этого больше похоже на структуру данных, а что на объект?

[source,cpp]
----
struct point {
    double x, y, z;
}

...

struct int_vector {
    size_t size;
    int* data;
}
----

=== Как C++ позволяет создавать объекты
////
== Задачи

Сегодня мы будем реализовывать иммутабельную строку.

Если строка иммутабельна, то её не нужно копировать, поэтому
мы назовём её `lazy_string`.

=== Идея реализации

Прежде чем приступать к задаче, подумаем, как удобнее всего было бы
реализовать такую строку.

Строке надо хранить где-то свои данные,
но эти данные могут быть разделены между разными строками.

Для удобного разделения данных заведем специальный класс.

=== Задача №1

Реализуйте класс `shared_buffer`.

`shared_buffer` хранит в себе массив чаров и его размер.

Несколько `shared_buffer`-ов могут ссылаться на один и тот же участок памяти.

ifdef::backend-revealjs[=== !]

Когда последний `shared_buffer`, ссылающийся на память, очищается,
очищается и эта память.

ifdef::backend-revealjs[=== !]

У `shared_buffer` должны быть следующие методы:

* Конструктор от size_t и конструктор копирования.
* Оператор присваивания.
* `get_size`, возвращающий размер.
* `get_data`, возвращающий аллоцированный участок памяти.

=== Задача №2

Используя `shared_buffer`, реализуйте класс `lazy_string`.

У `lazy_string` должны быть следующие методы:

* Дефолтный конструктор.
* Неявный конструктор от `char const*`.
* Конструктор копирования, оператор присваивания.

ifdef::backend-revealjs[=== !]

* `get_size`.
* `at`, возвращающий символ по индексу.

ifdef::backend-revealjs[=== !]

Также реализуйте свободную функцию `concat`, принимающую две `lazy_string`
и возвращающую их конкатенацию.

=== Задача №3

TBD