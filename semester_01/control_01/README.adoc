= Контрольная работа №1: Социальная сеть
:idprefix: slide_
:revealjs_theme: white
:revealjs_hash: true

== Введение
[.text-right]
В целях сопротивления цензуре мы разработаем собственную (хоть и простую)
*социальную сеть*, в которой можно будет постить сообщения, быстро удалять
лишние посты, а также сортировать ленту по популярности постов.

ifdef::backend-revealjs[=== !]

Ленту довольно удобно хранить в виде *односвязного списка*, чтобы можно было быстро
(без реаллокаций) добавлять посты в начало, и так же быстро удалять посты из середины
списка.

== Ограничения и пожелания

=== Процесс сдачи:

* Заводите ветку с названием `sem_1_control_01`.
* Пушите решение в неё.
* Создаете PR, вешаете своего ревьюера.

=== Процесс решения:

* В тестах (test.cpp) есть дефайны `PART_1`, `PART_2` и т.д..
* Они закомментированы.
* Начиная работать над задачей N, раскомментируйте дефайн `PART_N`.

=== Запрещено:

* Использовать контейнеры и функции STL для реализации алгоритма.
* Это касается в т.ч. `std::string`, `std::vector`.
* Если вы хотите что-то использовать, но сомневаетесь -- спрашивайте.

=== Необходимо:

* Проверять на утечки памяти (valgrind).
* Предполагается, что вы выполните вашу контрольную работу в двух файлах:
** network.hpp - объявления структур и функций для API.
** network.cpp - реализация функций из API.
* Можно пользоваться функциями из `cstring` для работы со строками


== Часть 1 (1 балл)

Реализуйте API для создания постов в вашей социальной сети.

API представляет собой следующие функции:

=== Создание и удаление постов

[source,cpp]
----
// network.hpp
struct Post;

// создает новый пост с сообщением message
// от имени пользователя user
// и добавляет его в начало ленты
Post* create_post(
    char const* user,
    char const* text,
    Post* head = nullptr
);

// деаллоцирует ленту
void destroy_posts(Post const* head);
----

=== Работа с постами

[source,cpp]
----
// возвращает указатель на предыдущий пост или nullptr,
// если его не существует
Post* previous(Post const* post);

char const* get_user(Post const* post); // возвращает автора поста
char const* get_text(Post const* post); // возвращает сообщение в посте
----

=== Замечания

* Предполагается, что `create_post` копирует переданные ему строки.
* Вы можете (и должны) добавлять поля к структуре `Post` по мере выполнения задач.
* Во задачах запрещено использовать рекурсию.

== Часть 2 (0.5 балла)

В случае опасности нужно уметь быстро удалять посты с определенным содержанием — например, с хештегом `#ИТМО` или словом `CSC`.

ifdef::backend-revealjs[=== !]

Добавьте в ваш API функцию, очищающую ленту от постов с компрометирующим содержимым:

[source,cpp]
----
// удаляет все посты, в тексте которых
// хоть раз встречается подстрока content
Post* remove_by_content(Post* head, char const* content);
----

=== Замечания

* `remove_by_content` модифицирует ленту (удаляет из неё посты).
* `remove_by_content` возвращает указатель на первый пост в новой ленте.
* Если в ленте не осталось постов, то возвращается `nullptr`.


== Задание №2.5 на +0.5 балла

Обобщите удаление постов с использованием `std::function`, и реализуйте `remove_by_content` через неё:

[source,cpp]
----
// функция, принимающая Post const* и возвращающая bool
typedef std::function<bool(Post const*)> PostPredicate;

// удаляет из ленты все посты,
// для которых predicate вернул true
Post* remove_if(Post* head, PostPredicate const& predicate);
----

== Часть 3 (0.5 балла)
Чтобы распределить нагрузку между серверами, запросы о созданиях постов могут приходить на разные машины. Но рано или поздно посты приходится сливать в одну общую ленту.

ifdef::backend-revealjs[=== !]

Добавьте в ваш API метод, позволяющий сливать две ленты в одну:

[source,cpp]
----
// возвращает время создания поста в наносекундах
int64_t timestamp(Post const* post);

// сливает две ленты в одну так, чтобы посты шли в хронологическом порядке
Post* merge(Post* head_1, Post* head_2);
----

ifdef::backend-revealjs[=== !]

Текущее время в наносекундах можно (нужно) получать с помощью следующей функции:

[source,cpp]
----
#include <chrono>
// это не часть API и не должно быть в network.hpp!
int64_t get_current_nanos() {
    using namespace std::chrono;
    return system_clock::now().time_since_epoch().count();
}
----

== Часть 4* (опциональное задание, 1 балл)
Пора добавить в нашу соцсеть лайки и научиться упорядочивать посты по их популярности! Добавьте в ваш API следующие функции:

[source,cpp]
----
// увеличивает количество лайков на 1
void like_post(Post* post);

// возвращает количество лайков поста
size_t get_likes(Post* post);
----

ifdef::backend-revealjs[=== !]

[source,cpp]
----
// сортирует посты по убыванию количества лайков
// (посты с одинаковым количеством лайков сортируются по убыванию timestamp)
// ВАЖНО: сортировка должна иметь сложность O(n log n) операций
Post* sort_by_likes(Post* post);

// сортирует посты по убыванию значения timestamp
Post* sort_by_timestamp(Post* post);
----

