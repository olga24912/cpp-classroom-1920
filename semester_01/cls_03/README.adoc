= Семинар №3: Работа с памятью, выполнение программ
:revealjs_theme: white

== Типичные ошибки прошлого семинара

Рассмотрим типичные ошибки/недочеты, допущенные при решении прошлого семинара.

=== "Голые" заголовочные файлы

Рассмотрим такой файлик:

.a.hpp
[source,cpp]
----
int A = 42;
----

В чем его проблема?

ifdef::backend-revealjs[=== !]

Если включен два раза — повторное определение:

.main.cpp
[source,cpp]
----
#include "a.hpp"
#include "a.hpp"
----

Как не писать такого, и все-равно наткнуться на проблему?

ifdef::backend-revealjs[=== !]

Транизитивность включения:

.super_data.hpp
[source,cpp]
----
int A = 42;
----

.super_algo.hpp
[source,cpp]
----
#include "super_data.hpp"
----

.super_util.hpp
[source,cpp]
----
#include "super_data.hpp"
----

.main.cpp
[source,cpp]
----
#include "super_algo.hpp"
#include "super_util.hpp"
----


Как чинить? Иклюд гарды!

=== Включение .cpp файлов

Рассмотрим такой файл:

.code.cpp
[source,cpp]
----
int fun() {...}
----

ifdef::backend-revealjs[=== !]

Он включен ещё в два:

.file_2.cpp
[source,cpp]
----
#include "code.cpp"
----

.file_1.cpp
[source,cpp]
----
#include "code.cpp"
----

Где проблема?

ifdef::backend-revealjs[=== !]

Если в файле есть определения (даже inline), то каждое определение
скомпилируется по разу на единицу трансляции.

Это замедляет компиляцию.

== Цели занятия

- Поработать с разными видами памяти в C++.
- Научиться использовать статический и динамический массивы.
//- Порешать задачи на константные указатели и увидеть “заразность” const.
//- Попробовать ловить утечки памяти.

== Статические массивы

Когда использовать:

- Количество элементов (верхняя граница) известно на этапе компиляции.
- Размер массива меньше размера стека (стек -- несколько мегабайт).
- Хватает области видимости переменной.

=== Инициализация

[%step]
* `int arr[3];`
* -> `{3 x garbage}`
* `int arr[3] = {}`
* -> `{0, 0, 0}`
* `int arr[3] = {1, 2}`
* -> `{1, 2, 0}`

ifdef::backend-revealjs[=== !]
[%step]
* `int arr[3] = {1, 2, 3}`
* -> `{1, 2, 3}`
* `int arr[] = {1, 2}`
* -> `{1, 2}`

=== Использование

* Доступ к элементу: `arr[10]`.
* Можно передавать в функции, но с потерей информации о размере.
** Происходит каст к указателю.
* Нельзя возвращать из функции.

== Динамическая память

Когда использовать:

- Требуемое количество заранее неизвестно (зависит от данных).
- Память должна "пережить" вызов метода, где она выделена.

=== Получение и освобождение

* CPP-style (используйте его):
** `int* i = new int(10); delete i;`
** `int* arr = new int[10] {1, 2, 3}; delete[] arr`
* C-style
** `void* buffer = malloc(1024); free(buffer);`

ifdef::backend-revealjs[=== !]

Память после использования нужно освободить ровно один раз
*правильным (парным) способом*.

=== Инициализация

[source,cpp]
----
int* arr = new int[length](); // значение по-умолчанию
std::fill(arr, arr+length, INITIAL_VALUE)
std::fill_n(arr, length, INITIAL_VALUE)
----

== Типичные ошибки работы с памятью

* Несимметричное использование оператора new и delete, new[] и delete[] приводит к undefined behavior.
* Утечки памяти
* Use after free

ifdef::backend-revealjs[=== !]

* Чтение или запись за границами выделенной памяти
* Использование неинициализированной памяти

== Как запускать тесты (под Unix)

Если вы пользуетесь CLion или VisualStudio, продолжайте ими пользоваться!

Если нет, то вот как собрать тесты из консоли:

ifdef::backend-revealjs[=== !]

* Переходите в папку `cls_03`.
* В файле `CMakeLists.txt` раскомментируете `add_executable` для задачи, с которой хотите работать.
* Создаете папку `build`.

ifdef::backend-revealjs[=== !]

* Из папки `build` запускаете команду `cmake ..`
* В папке build появляется `Makefile`; его можно запустить командой `make`.
* В `build` появляются исполняемые файлы с тестами.

== Задачи

=== Задача №1

Разминка. Напишите несколько функций на C++.

Инты -- это `int`, для описания количества используйте `size_t`.

Под массивом подразумевается прием по указателю.

ifdef::backend-revealjs[=== !]

* `sum` - принимает массив интов и количество элементов в массиве; возвращает их сумму.
* `count_numbers` - принимает массив интов в диапазоне [0, 9] и количество элементов в массиве; возвращает
количество уникальных чисел в массиве.
// Старые задания
//* `mins_suffix` - принимает массив интов, их количество, и возвращает массив указателей на инты:
//** Указатель на позиции i указывает на минимальный элемент в исходном массиве в диапазоне от 0 до i включительно.

ifdef::backend-revealjs[=== !]

* `sort` - принимает массив интов и их количество; возвращает массив из указателей.
** Указатель в позиции `i` указывает на элемент оригинального массива,
который должен стоять на позиции `i` в отсортированном массиве.
** Допускается асимптотика n^2.
// Старые задания
//* `min` - принимает массив интов, также начало (включительно) и конец диапазона (не включительно), на котором нужно найти минимум. Возвращает
//указатель на минимальный элемент, или nullptr, если такого нет.
//** Реализовать через `mins_suffix`.

=== Задача №2

Написать функцию `ladder_combinations`, которая,
используя статический массив, вычисляет для числа `N` (`0 \<= N < 21`),
сколько существует способов забраться на лестницу из N ступеней,
если можно шагать на каждую по очереди или через одну.

=== Задача №3

Напишите функцию `concat`, которая принимает
два участка памяти и аллоцирует новый, содержащий
в себе данные обоих участков.

ifdef::backend-revealjs[=== !]

[source, cpp]
----
char const* concat(
    char const a[],
    size_t a_size,
    char const b[],
    size_t b_size,
    size_t& concat_size
);
----

Смотрите тесты для примеров поведения.

=== Задача №4

Реализовать методы для аллокации матрицы интов MxN и для её освобождения.

При пллокации разрешено делать не более 2 аллокаций динамической памяти.

В сигнатуре функций отсутствуют `const`-ы -- расставьте их правильно
и объясните свои решения в комментарии.

ifdef::backend-revealjs[=== !]

Требуется поддержка индексации вида:

----
matrix[i][j] = 10;
----

Нужно использовать операторы `new`, `delete` и арифметику указателей.